# Справочник по фильтрам

Это справочный документ со списком фильтров и их аргументов.

## Основные аргументы

Ниже приведены основные аргументы, применимые **ко всем фильтрам**. Обратите внимание, что они объединяются для создания полного [выражения поиска](https://docs.djangoproject.com/en/stable/ref/models/lookups/#module-django.db.models.lookups), которое является левой частью вызова ORM `.filter()`.

### field\_name

Имя поля модели, по которому выполняется фильтрация. Если этот аргумент не указан, по умолчанию используется имя атрибута фильтра в классе **FilterSet**. Имена полей могут пересекать отношения, соединяя связанные части с помощью разделителя поиска ORM (`__`). например, `manufacturer__name`.

### lookup\_expr

[Поиск поля](https://docs.djangoproject.com/en/stable/ref/models/querysets/#field-lookups), который должен выполняться при вызове фильтра. По умолчанию **exact**. **Lookup\_expr** может содержать преобразования, если части выражения соединены разделителем поиска ORM (`__`). например, отфильтруйте дату и время по части года `year__gt`.

## Только ключевые аргументы (ключ-значение)

Ниже приведены **необязательные** аргументы, которые можно использовать для изменения поведения всех фильтров.

### label

Метка, как она будет отображаться в HTML, аналогична аргументу **label** поля формы. Если **label** не указана, будет создана подробная метка на основе поля **field\_name** и частей **lookup\_expr** (см.: <mark style="color:purple;">FILTERS\_VERBOSE\_LOOKUPS</mark>).

### method

Необязательный аргумент, указывающий фильтру, как обрабатывать набор запросов. Он может принимать либо вызываемый объект, либо имя метода в **FilterSet**. Вызываемый объект получает **QuerySet**, имя поля модели для фильтрации и значение для фильтрации. Он должен вернуть отфильтрованный набор запросов.

Обратите внимание, что значение проверяется полем `Filter.field`, поэтому преобразование необработанных значений и проверка пустых значений не нужны.

```python
class F(FilterSet):
    """Отфильтровать книги по тому, опубликованы ли книги или нет"""
    published = BooleanFilter(field_name='published_on', method='filter_published')

    def filter_published(self, queryset, name, value):
        # построить полное выражение поиска.
        lookup = '__'.join([name, 'isnull'])
        return queryset.filter(**{lookup: False})

        # в качестве альтернативы вы можете жестко закодировать поиск, например,
        # return queryset.filter(published_on__isnull=False)

    class Meta:
        model = Book
        fields = ['published']


# Вызываемые объекты также могут быть определены вне области видимости класса.
def filter_not_empty(queryset, name, value):
    lookup = '__'.join([name, 'isnull'])
    return queryset.filter(**{lookup: False})

class F(FilterSet):
    """Отфильтровать книги по тому, опубликованы ли книги или нет"""
    published = BooleanFilter(field_name='published_on', method=filter_not_empty)

    class Meta:
        model = Book
        fields = ['published']
```

### distinct

Логическое значение, указывающее, будет ли фильтр использовать **distinct** в наборе запросов. Этот параметр можно использовать для устранения повторяющихся результатов при использовании фильтров, охватывающих взаимосвязи. По умолчанию имеет значение `False`.

### exclude

Логическое значение, указывающее, должен ли фильтр использовать **filter** или **exclude** в наборе запросов. По умолчанию имеет значение `False`.

### required

Логическое значение, указывающее, требуется ли фильтр или нет. По умолчанию имеет значение `False`.

### \*\*kwargs

Любые дополнительные аргументы ключевого слова сохраняются как параметр фильтра **extra**. Они предоставляются сопровождающему полю формы **Field** и могут использоваться для предоставления аргументов, таких как **choices**. Некоторые аргументы, связанные с полем:

### widget

Класс **Widget** `django.form`, который будет представлять **Filter**. В дополнение к виджетам, включенным в Django, которые вы можете использовать, есть дополнительные, которые предоставляет **django-filter**, которые могут быть полезны:

* <mark style="color:purple;">LinkWidget</mark> — отображает параметры аналогично тому, как это делает админка Django, в виде серии ссылок. Ссылка для выбранного варианта будет иметь `class="selected"`.
* <mark style="color:purple;">BooleanWidget</mark> — этот виджет преобразует входные данные в значения `True/False` Python. Он преобразует все варианты регистра `True` и `False` во внутренние значения Python.
* <mark style="color:purple;">CSVWidget</mark> — этот виджет ожидает значение, разделенное запятыми, и преобразует его в список строковых значений. Ожидается, что класс поля обрабатывает список значений, а также преобразование типов.
* <mark style="color:purple;">RangeWidget</mark> — этот виджет используется с **RangeFilter** для создания двух элементов ввода формы с использованием одного поля.
