# FAQ django-spectacular

## Я использую библиотеку/приложение XXX, и сгенерированная схема неверна или повреждена

Иногда библиотеки DRF плохо взаимодействуют с механикой самоанализа. Проверьте [шаблоны расширения](skhemy-rasshirenii.md) на наличие уже доступных исправлений. Если их нет, узнайте, как легко [настроить рабочий процесс и схему](nastroika-rabochego-processa-i-skhemy.md). Не стесняйтесь вносить недостающие исправления.

Если вы считаете, что это ошибка в **drf-spectacular**, откройте [вопрос](https://github.com/tfranzel/drf-spectacular/issues).

## Мой пользовательский интерфейс Swagger и/или страница Redoc пусты

Скорее всего, вы используете [django-csp](https://django-csp.readthedocs.io/en/latest/index.html). Загляните в консоль браузера и убедитесь, что у вас есть ошибки **Content Security Policy**. По умолчанию **django-csp** обычно ломает наши пользовательские интерфейсы по двум причинам: внешние ассеты и встроенные скрипты.

Использование [sidecar](https://github.com/tfranzel/drf-spectacular#self-contained-ui-installation) смягчит нарушение загрузки удаленных ресурсов, предоставляя ресурсы от **self**. В качестве альтернативы вы также можете адаптировать **CSP\_DEFAULT\_SRC**, чтобы разрешить использование этих ресурсов CDN.

### Решение для пользовательского интерфейса Swagger UI:

```python
# Option: SIDECAR
SPECTACULAR_SETTINGS = {
     ...
    'SWAGGER_UI_DIST': 'SIDECAR',
    'SWAGGER_UI_FAVICON_HREF': 'SIDECAR',
}
CSP_DEFAULT_SRC = ("'self'", "'unsafe-inline'")
CSP_IMG_SRC = ("'self'", "data:")

# Option: CDN
CSP_DEFAULT_SRC = ("'self'", "'unsafe-inline'", "cdn.jsdelivr.net")
CSP_IMG_SRC = ("'self'", "data:", "cdn.jsdelivr.net")
```

{% hint style="info" %}
В зависимости от того, насколько вы параноики, вы можете избежать использования **unsafe-inline**, используя вместо этого **SpectacularSwaggerSplitView**, который выполняет отдельный запрос для сценария. Однако обратите внимание, что некоторые развертывания с перезаписью URL-адресов сломают его. Используйте эту опцию только в том случае, если вам это действительно необходимо.
{% endhint %}

### Решение для Redoc:

```python
# Option: SIDECAR
SPECTACULAR_SETTINGS = {
     ...
    'REDOC_DIST': 'SIDECAR',
}
# Option: CDN
CSP_DEFAULT_SRC = ("'self'", "cdn.jsdelivr.net")

# требуется для обоих CDN и SIDECAR
CSP_WORKER_SRC = ("'self'", "blob:")
CSP_IMG_SRC = ("'self'", "data:", "cdn.redoc.ly")
CSP_STYLE_SRC = ("'self'", "'unsafe-inline'", "fonts.googleapis.com")
CSP_FONT_SRC = ("'self'", "fonts.gstatic.com")
```

## Я не могу использовать @extend\_schema в коде библиотеки

Вы можете легко адаптировать самоанализ для библиотек/приложений с помощью механизма расширения. Расширения обеспечивают простой способ присоединения информации о схеме к коду, который вы не можете изменить иначе. Взгляните на [настройку рабочего процесса и схемы](nastroika-rabochego-processa-i-skhemy.md), чтобы узнать, как использовать расширения.

## Я получаю пустую схему или отсутствуют конечные точки

Обычно это происходит из-за версий (реже из-за разрешений).

Если вы используете управление версиями на всех конечных точках, это может быть ожидаемым результатом. По умолчанию схема будет содержать только неверсированные конечные точки. Явно укажите, какую версию вы хотите сгенерировать.

```bash
./manage.py spectacular --api-version 'YOUR_VERSION'
```

Она будет содержать конечные точки без версии вместе с конечными точками для указанной версии.

Для представлений схемы вы можете либо установить класс управления версиями (неявное управление версиями через запрос), либо явно переопределить версию с помощью `SpectacularAPIView.as_view(api_version='YOUR_VERSION')`.

## Я ожидал другую схему

Иногда представления объявляют одно (через **serializer\_class** и **queryset**), а делают совершенно другое. Обычно это объясняется тем, что код библиотеки становится гибким в различных ситуациях. В таких случаях лучше отменить то, что решил самоанализ, и прямо указать, чего следует ожидать. Выполните шаги в [настройке рабочего процесса и схемы](nastroika-rabochego-processa-i-skhemy.md), чтобы адаптировать свою схему.

## Я получаю повторяющиеся операции с суффиксом {format}

Ваше приложение, вероятно, использует **format\_suffix\_patterns** DRF. Если эти операции нежелательны в вашей схеме, вы можете просто исключить их с помощью уже предоставленного [хука предварительной обработки](nastroika-rabochego-processa-i-skhemy.md#shag-7-preprocessing-khukov).

## Я получаю много предупреждений

Предупреждения выдаются, чтобы информировать вас об обнаруженных проблемах со схемой. Некоторые шаблоны использования, такие как **@api\_view** или **APIView**, предоставляют очень мало информации о вашем API. В таких случаях вы можете легко дополнить эти конечные точки и сериализаторы дополнительной информацией. Посмотрите на параметры [настройки рабочего процесса и схемы](nastroika-rabochego-processa-i-skhemy.md), чтобы заполнить эти пробелы и убрать предупреждения.

## Я получаю предупреждения относительно моего Enum или у моих имен Enum есть странный суффикс

Это связано с тем, что по умолчанию активируется хук постобработки **Enum**, который пытается найти имя для набора вариантов перечисления.

Механизм именования использует имя поля и, возможно, имя компонента, за которым следует суффикс, если это необходимо, если есть конфликты (если есть два поля перечисления с одинаковым именем, но с разным набором вариантов). Это автоматически обработает все возникающие проблемы, а также уведомит вас о потенциальных проблемах двух видов:

* несколько имен создаются для одного и того же набора значений из-за разных имен полей (например, если у вас есть одно перечисление валюты, используемое разными полями с именами, такими как **payment\_currency** и **preferred\_currency**, механизм именования по умолчанию будет рассматривать это как два разных перечисления, но выдает предупреждение).
* конфликты, которые приводят к необходимости суффикса, как указано выше.

Вы можете решить (или отключить) проблемы с перечислением, добавив запись в параметр **ENUM\_NAME\_OVERRIDES**. Значения могут принимать форму вариантов (список кортежей), списков значений (список строк) или импортированных строк. Также поддерживаются классы Django **models.Choices** и Python **Enum**. Ключ — это строка, которую вы выбираете в качестве имени для этого набора значений.

Например:

```python
SPECTACULAR_SETTINGS = {
    ...
    'ENUM_NAME_OVERRIDES': {
        # переменная, содержащая список кортежей, например, [('US', 'US'), ('RU', 'RU'),]
        'LanguageEnum': language_choices,
        # настоящий Enum или класс models.Choices
        'CountryEnum': 'import_path.enums.CountryEnum',
        # choices — это атрибут класса CurrencyContainer, содержащий список кортежей.
        'CurrencyEnum': 'import_path.CurrencyContainer.choices',
    }
}
```

Если у вас есть несколько семантически различных перечислений с одинаковым набором значений, и вам нужны разные имена для них, этот механизм не будет работать.

## Мои конечные точки используют разные сериализаторы в зависимости от ситуации

Добро пожаловать в реальный мир! Используйте **@extend\_schema** в сочетании с **PolymorphicProxySerializer** следующим образом:

```python
class PersonView(viewsets.GenericViewSet):
    @extend_schema(responses={
        200: PolymorphicProxySerializer(
                component_name='Person',
                # на 200 возвращается либо юридическое, либо физическое лицо
                serializers=[LegalPersonSerializer, NaturalPersonSerializer],
                resource_type_field_name='type',
        ),
        500: YourOptionalErrorSerializer,
    })
    def retrieve(self, request, *args, **kwargs)
        pass
```
