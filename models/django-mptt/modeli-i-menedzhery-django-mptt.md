# Модели и менеджеры django-mptt

## Настройка модели Django для MPTT

Начните с базового подкласса **MPTTModel**, примерно так:

```python
from django.db import models
from mptt.models import MPTTModel, TreeForeignKey

class Genre(MPTTModel):
    name = models.CharField(max_length=50, unique=True)
    parent = TreeForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True, blank=True,
        related_name='children'
    )
```

Вы должны определить родительское поле **parent**, которое является **ForeignKey** для **«self»**. Рекомендуется: используйте **TreeForeignKey**. Вы можете назвать это как-то по-другому, если хотите - см. [Параметры модели ниже](modeli-i-menedzhery-django-mptt.md#undefined).

Поскольку вы наследуете **MPTTModel**, ваша модель также будет иметь ряд других полей: **level**, **lft**, **rght** и **tree\_id**. В большинстве случаев вам не нужно будет использовать эти поля напрямую, но полезно знать, что они есть.

Обратите внимание, что если вы используете множественное наследование, **MPTTModel** обычно должен быть первым классом, от которого наследуется:

```python
class Genre(MPTTModel,Foo,Bar):
    name = models.CharField(max_length=50, unique=True)
```

Так как **MPTTModel** наследуется от **models.Model**, это очень важно, когда у вас множественное наследование в «diamond style»: вы наследуете от двух моделей, которые наследуются от одного и того же базового класса (например, **models.Model**). В этом случае, если **MPTTModel** не является первой моделью, вы можете получить ошибки при проверке модели, например `AttributeError: 'NoneType' object has no attribute 'name'`.

## Параметры модели

Иногда вам может понадобиться изменить имена вышеуказанных полей, например, если у вас уже есть поле с именем **level** и вы хотите избежать конфликтов.

Чтобы изменить имена, создайте класс **MPTTMeta** внутри вашего класса:

```python
class Genre(MPTTModel):
    name = models.CharField(max_length=50, unique=True)
    parent = TreeForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True, blank=True,
        related_name='children'
    )

    class MPTTMeta:
        level_attr = 'mptt_level'
        order_insertion_by=['name']
```

Доступные параметры для класса **MPTTMeta**:

### parent\_attr

Имя поля, которое связывает модель с самой собой, так что каждый экземпляр может быть потомком другого экземпляра. По умолчанию `'parent'`.

Пользователи несут ответственность за настройку этого поля в классе модели, что можно сделать следующим образом:

```python
parent = TreeForeignKey(
    'self',
    on_delete=models.CASCADE,
    null=True, blank=True,
    related_name='children'
)
```

Для следующих четырех аргументов, если поля с заданными именами не существуют, они будут добавлены в модель динамически:

### left\_attr

Имя поля, которое содержит индикатор края левого узла дерева, которое должно быть **PositiveIntegerField**. По умолчанию `'lft'`.

### right\_attr

Имя поля, которое содержит индикатор ребра правого узла дерева, которое должно быть **PositiveIntegerField**. По умолчанию `'rght'`.

### tree\_id\_attr

Имя поля, которое содержит идентификатор дерева каждого узла, которое должно быть **PositiveIntegerField**. По умолчанию `'tree_id'`.

Элементы, у которых нет родителя, считаются `"root"` узлами в дереве, и им назначается новый идентификатор дерева. Всем потомкам корневых узлов будет присвоен тот же идентификатор дерева, что и их корневому узлу.

### level\_attr

Имя поля, которое содержит уровень (отсчитываемый от нуля), на котором находится элемент в дереве, который должен быть **PositiveIntegerField**. По умолчанию `'level'`.

Например, корневые узлы будут иметь уровень `0`, а их непосредственные дочерние узлы будут иметь уровень `1`.

### order\_insertion\_by

Список имен полей, которые должны определять порядок, когда вставляются новые узлы дерева или переопределяются существующие узлы, причем первым идет наиболее значимое имя поля порядка. По умолчанию `[]`.

Предполагается, что любое поле, идентифицированное как определяющее порядок, никогда не будет иметь значение `NULL` в базе данных.

{% hint style="info" %}
Это потребует дополнительного запроса к базе данных, чтобы определить, где должны располагаться узлы при их сохранении. Эта опция удобна, если вы поддерживаете в основном статические структуры, такие как деревья категорий, которые всегда должны быть в алфавитном порядке.
{% endhint %}

{% hint style="warning" %}
Будьте особенно осторожны, если вы сохраняете ссылки на объекты в базе данных при использовании этого поля. В случае вставки или других обновлений, когда **django-mptt** потребуется переупорядочить дерево, вы, скорее всего, останетесь с оборванными ссылками. Подробности см. в [разделе order\_insertion\_by](rukovodstvo-django-mptt.md#order\_insertion\_by-gotcha).
{% endhint %}

## Регистрация существующих моделей

Предпочтительный способ регистрации модели в **django-mptt** — создание подкласса **MPTTModel**.

Однако иногда это не работает. Например, предположим, что вы хотите изменить модель группы Django, сделав ее иерархической.

Вы не можете создать подкласс **MPTTModel**, не изменив исходный код группы. Вместо этого вы можете сделать:

```python
import mptt
from mptt.fields import TreeForeignKey
from django.contrib.auth.models import Group

# добавить родительский внешний ключ
TreeForeignKey(
    Group,
    on_delete=models.CASCADE,
    blank=True, null=True
).contribute_to_class(Group, 'parent')

mptt.register(Group, order_insertion_by=['name'])
```

## Методы экземпляра MPTTModel

Подклассы **MPTTModel** имеют следующие методы экземпляра:

### get\_ancestors(ascending=False, include\_self=False)

Создает **QuerySet**, содержащий предков экземпляра модели.

По умолчанию они расположены в порядке убывания (сначала корневой предок, последний непосредственный родитель); передача `True` для аргумента **ascending** изменит порядок (сначала непосредственный родитель, последним корневой предок).

Если **include\_self** имеет значение `True`, **QuerySet** также будет включать сам экземпляр модели.

Вызывает **ValueError**, если экземпляр еще не сохранен.

### get\_children()

Создает **QuerySet**, содержащий непосредственных дочерних элементов экземпляра модели, в порядке дерева.

Преимущество использования этого метода по сравнению с обратным отношением, предоставляемым ORM к дочерним элементам экземпляра, заключается в том, что можно избежать запроса к базе данных в случае, когда экземпляр является конечным узлом (у него нет дочерних элементов).

Вызывает **ValueError**, если экземпляр еще не сохранен.

### get\_descendants(include\_self=False)

Создает **QuerySet**, содержащий потомков экземпляра модели в порядке дерева.

Если **include\_self** имеет значение `True`, **QuerySet** также будет включать сам экземпляр модели.

Вызывает **ValueError**, если экземпляр еще не сохранен.

### get\_descendant\_count()

Возвращает количество потомков экземпляра модели на основе индикаторов краев левого и правого узлов дерева. Таким образом, это не требует доступа к базе данных.

### get\_family()

Возвращает **QuerySet**, содержащий предков, саму модель и потомков в порядке дерева.

Вызывает **ValueError**, если экземпляр еще не сохранен.

### get\_next\_sibling()

Возвращает следующий одноуровневый экземпляр модели в дереве или `None`, если у него нет следующего одноуровневого элемента.

Вызывает **ValueError**, если экземпляр еще не сохранен.

### get\_previous\_sibling()

Возвращает предыдущий одноуровневый элемент экземпляра модели в дереве или `None`, если у него нет предыдущего одноуровневого элемента.

Вызывает **ValueError**, если экземпляр еще не сохранен.

### get\_root()

Возвращает корневой узел дерева экземпляра модели.

Вызывает **ValueError**, если экземпляр еще не сохранен.

### get\_sibling(include\_self=False)

Создает **QuerySet**, содержащий братьев и сестер экземпляра модели. Корневые узлы считаются братьями и сестрами других корневых узлов.

Если **include\_self** имеет значение `True`, **QuerySet** также будет включать сам экземпляр модели.

Вызывает **ValueError**, если экземпляр еще не сохранен.

### insert\_at(target, position='first-child', save=False)

Позиционирует экземпляр модели (который еще не должен быть вставлен в базу данных) в дереве на основе цели и положения (при необходимости).

Если для **save** задано значение `True`, также будет вызван метод `save()` экземпляра модели.

### is\_child\_node()

Возвращает `True`, если экземпляр модели является дочерним узлом, в противном случае — `False`.

### is\_leaf\_node()

Возвращает `True`, если экземпляр модели является конечным узлом (у него нет дочерних элементов, то есть это "лист" дерева), в противном случае — `False`.

### is\_root\_node()

Возвращает `True`, если экземпляр модели является корневым узлом, в противном случае — `False`.

### move\_to(target, position='first-child')

Перемещает экземпляр модели в другое место в дереве в зависимости от **target** и **position** (при необходимости). Если перемещается без каких-либо исключений, будет отправлен сигнал **node\_moved**.

{% hint style="info" %}
Предполагается, что при вызове этого метода поля дерева в экземпляре, для которого вы его вызвали, и в любом переданном экземпляре **target** отражают текущее состояние базы данных.

Изменение полей дерева вручную перед вызовом этого метода или использование полей дерева, которые не синхронизированы с базой данных, может привести к тому, что структура дерева будет переведена в неточное состояние.
{% endhint %}

Если **target** является другим экземпляром модели, он будет использоваться для определения типа движения, которое должно произойти, и будет использоваться в качестве основы для позиционирования модели при ее перемещении в сочетании с аргументом **position**.

**target** со значением `None` указывает, что экземпляр модели следует превратить в корневой узел. Аргумент **position** в этом случае игнорируется.

Допустимые значения аргумента **position** и их влияние на движение:

* `'first-child'` - Перемещаемый экземпляр должен иметь **target**, установленную в качестве нового родителя, и должен быть помещен в качестве первого дочернего элемента в древовидной структуре.
* `'last-child'` - Перемещаемый экземпляр должен иметь **target**, установленную в качестве нового родителя, и должен быть помещен в качестве последнего дочернего элемента в древовидной структуре.
* `'left'` - Перемещаемый экземпляр должен иметь родительский объект **target**, установленный в качестве его нового родителя, и должен быть помещен _непосредственно_ перед **target** в древовидной структуре.
* `'right'` - Перемещаемый экземпляр должен иметь родителя **target**, установленного в качестве его нового родителя, и должен быть помещен _непосредственно_ после **target** в древовидной структуре.

Ошибка **ValueError** будет вызвана, если для аргумента **position** задано недопустимое значение.

Обратите внимание, что некоторые действия, которые вы можете попытаться сделать с помощью этого метода, недействительны — например, попытка сделать экземпляр собственным дочерним элементом или дочерним элементом одного из его потомков. В этих случаях будет вызвано исключение **mptt.exceptions.InvalidMove**.

Сам экземпляр также будет изменен в результате этого вызова, чтобы отразить состояние его обновленных полей дерева в базе данных, поэтому можно безопасно сохранить его или использовать его поля дерева после того, как вы вызвали этот метод.

## TreeForeignKey, TreeOneToOneField, TreeManyToManyField

_Новое в версии 0.5_.

Рекомендуется использовать **mptt.fields.TreeForeignKey** везде, где у вас есть внешний ключ к модели **MPTT**. Это включает в себя ссылку **parent**, которую вы только что создали для своей модели.

**TreeForeignKey** похож на обычный **ForeignKey**, но он заставляет поле формы по умолчанию отображать варианты в виде дерева.

Есть также **TreeOneToOneField** и **TreeManyToManyField**, если они вам нужны. Они могут оказаться полезными для других моделей, которые каким-то образом связаны с вашей моделью дерева.

{% hint style="info" %}
Вы не можете использовать «многие ко многим» в качестве поля `'parent'`. Это потому, что алгоритм **mptt** обрабатывает только деревья, а не произвольные графы. Дерево, в котором узлы могут иметь несколько родителей, на самом деле вовсе не дерево.
{% endhint %}

## Пользовательский менеджер TreeManager

Менеджером по умолчанию для **MPTTModel** является **TreeManager**.

Любой **QuerySet**, созданный с помощью этого менеджера, будет упорядочен на основе структуры дерева, при этом корневые узлы будут отображаться в порядке идентификаторов дерева, а их потомки будут упорядочены в порядке глубины.

### Методы

Доступны следующие методы менеджера:

#### disable\_mptt\_updates() и delay\_mptt\_updates()

Эти два метода возвращают диспетчеры контекста и оба предназначены для эффективного массового обновления больших деревьев. Дополнительные сведения см. в автоматически сгенерированных документах:

> * [delay\_mptt\_updates](https://django-mptt.readthedocs.io/en/latest/mptt.managers.html#mptt.managers.TreeManager.delay\_mptt\_updates)
> * [disable\_mptt\_updates](https://django-mptt.readthedocs.io/en/latest/mptt.managers.html#mptt.managers.TreeManager.disable\_mptt\_updates)

#### rebuild()

Перестраивает поля **mptt** для всей таблицы. Это может быть удобно:

* если ваше дерево каким-то образом повреждено.
* После больших массовых операций, когда вы использовали **disable\_mptt\_updates**

Рекомендуется перестроить дерево внутри блока `transaction.atomic()` для безопасности и повышения производительности.

#### add\_related\_count(queryset, rel\_cls, rel\_field, count\_attr, cumulative=False, extra\_filters={})

Добавляет количество связанных элементов к заданному **QuerySet**, используя его [дополнительный метод](https://docs.djangoproject.com/en/dev/ref/models/querysets/#extra-select-none-where-none-params-none-tables-none-order-by-none-select-params-none), для модели, которая имеет отношение к модели этого менеджера.

#### rel\_cls

Класс модели Django, имеющий отношение к модели этого менеджера.

#### rel\_field

Имя поля в **rel\_cls**, которое содержит отношение.

#### count\_attr

Имя атрибута, который должен быть добавлен к каждому элементу в этом **QuerySet**, содержащий количество экземпляров **rel\_cls**, связанных с ним через **rel\_field**.

#### cumulative

Если `True`, счетчик будет для каждого элемента и всех его потомков, в противном случае он будет для каждого элемента.

#### extra\_filters

Словарь с дополнительными параметрами, фильтрующими соответствующий набор запросов.

### Пример использования в админке

```python
from mptt.admin import DraggableMPTTAdmin
from .models import Category, Product

class CategoryAdmin(DraggableMPTTAdmin):
    mptt_indent_field = "name"
    list_display = ('tree_actions', 'indented_title',
                    'related_products_count', 'related_products_cumulative_count')
    list_display_links = ('indented_title',)

    def get_queryset(self, request):
        qs = super().get_queryset(request)

        # Добавить совокупное количество продуктов
        qs = Category.objects.add_related_count(
                qs,
                Product,
                'category',
                'products_cumulative_count',
                cumulative=True)

        # Добавить некумулятивное количество продуктов
        qs = Category.objects.add_related_count(qs,
                 Product,
                 'categories',
                 'products_count',
                 cumulative=False)
        return qs

    def related_products_count(self, instance):
        return instance.products_count
    related_products_count.short_description = 'Related products (for this specific category)'

    def related_products_cumulative_count(self, instance):
        return instance.products_cumulative_count
    related_products_cumulative_count.short_description = 'Related products (in tree)'
```

#### root\_node(tree\_id)

Возвращает корневой узел дерева с заданным идентификатором.

#### insert\_node(node, target, position='last-child', save=False)

Устанавливает состояние дерева для узла **node** (который еще не был вставлен в базу данных), поэтому он будет позиционироваться относительно данного узла **target**, как указано в **position** (если это уместно), когда он вставлен, с любым необходимым пространством, которое уже было сделано для этого.

**target** `None` указывает, что узел **node** должен быть последним корневым узлом.

Если **save** имеет значение `True`, перед возвратом будет вызван метод узла **node** `save()`.

#### move\_node(node, target, position='last-child')

Перемещает узел **node** на основе **target** относительно **position**, когда это необходимо.

**target** `None` указывает, что **node** должен быть удален из его текущей позиции и превращен в корневой узел. Если в этом случае узел **node** является корневым узлом, никаких действий предприниматься не будет.

Данный узел **node** будет изменен, чтобы отразить его новое состояние дерева в базе данных.

Дополнительные сведения см. в [документации по move\_to выше](modeli-i-menedzhery-django-mptt.md#move\_to-target-position-first-child).

#### root\_nodes()

Создает **QuerySet**, содержащий корневые узлы.

### Пример использования

В следующих примерах у нас есть модели **Category** и **Question**. **Question** имеет поле **category**, которое является **TreeForeignKey** для **Category**.

Получение списка корневых категорий, у которых есть атрибут **question\_count**, содержащий количество вопросов, связанных с каждым корнем и всеми его потомками:

```python
roots = Category.objects.add_related_count(Category.objects.root_nodes(), Question,
                                        'category', 'question_counts',
                                        cumulative=True)
```

Получение списка дочерних категорий, у которых есть атрибут **question\_count**, содержащий количество вопросов, связанных с каждой из них:

```python
node = Category.objects.get(name='Some Category')
children = Category.objects.add_related_count(node.get_children(), Question,
                                           'category', 'question_counts')
```
