# Утилиты для работы с деревьями

## Утилиты списка/дерева

Модуль **mptt.utils** содержит следующие функции для работы и создания списков экземпляров моделей, представляющих деревья.

### previous\_current\_next()

Из [http://www.wordaligned.org/articles/zippy-triples-served-with-python](https://wordaligned.org/articles/zippy-triples-served-with-python)

Создает итератор, который возвращает триплеты (предыдущий, текущий, следующий) с заполнением `None`, когда нет ни предыдущего, ни следующего доступного.

Эта функция полезна, если вы хотите пройтись по дереву по одному элементу за раз и вам нужно обратиться к предыдущему или следующему элементу в дереве. Он используется в реализации [tree\_item\_iterator()](utility-dlya-raboty-s-derevyami.md#undefined).

#### Обязательные аргументы

* **items** - Список или другой итерируемый элемент.

### tree\_item\_iterator()

Эта функция используется для реализации фильтра шаблона **tree\_info**, что дает два кортежа (элемент дерева, информационный словарь структуры дерева).

См. документацию **tree\_info** для получения дополнительной информации.

#### Обязательные аргументы

* **items** - Список или итерация экземпляров модели, представляющих дерево.

#### Необязательные аргументы

* **ancestors** - логический. Если `True`, список юникод-представлений предков текущего узла в порядке убывания (корневой узел первым, непосредственный родитель последним) будет добавлен в информационный словарь древовидной структуры `'dict'` под ключом `'ancestors'`.

### drilldown\_tree\_for\_node()

Эта функция используется в реализации тега шаблона Drilldown\_tree\_for\_node.

Он создает итерируемый объект, который дает экземпляры модели, представляющие дерево детализации для данного узла.

Дерево детализации состоит из предков узла, самого узла и его непосредственных дочерних элементов или всех потомков, все в порядке дерева.

Необязательные аргументы могут быть переданы для указания деталей отношения между классом данного узла и другим классом модели с целью добавления количества связанных элементов к дочерним элементам узла.

#### Обязательные аргументы

* node - Экземпляр модели, представляющий узел в дереве.

#### Необязательные аргументы

* **rel\_cls** - Класс модели, который имеет отношение к классу узла.
* **rel\_field** - Имя поля в **rel\_cls**, которое содержит отношение к классу узла.
* **count\_attr** - Имя атрибута, который должен быть добавлен к каждому дочернему узлу в дереве детализации (если есть), содержащий количество экземпляров **rel\_cls**, связанных с ним через **rel\_field**.
* **cumulative** - Если `True`, подсчет будет для элементов, связанных с дочерним узлом и всеми его потомками. По умолчанию имеет значение `False`.

### get\_cached\_tree()

Принимает список/набор запросов объектов модели в порядке **MPTT** слева (сначала в глубину) и кэширует дочерние и родительские объекты на каждом узле. Это позволяет перемещаться вверх и вниз по дереву без необходимости дальнейших запросов. Варианты использования включают использование рекурсивно включенного шаблона или произвольный обход деревьев.

Возвращает список узлов верхнего уровня. Если одно дерево было предоставлено полностью, список, конечно, будет состоять только из корневого узла дерева.

Также доступны псевдонимы для этой функции:

**mptt.templatetags.mptt\_tag.cache\_tree\_children** - Используйте для рекурсивного рендеринга в шаблонах.

**mptt.querysets.TreeQuerySet.get\_cached\_trees** - Полезно для цепочки с запросами; например, `Node.objects.filter(**kwargs).get_cached_trees()`

#### Обязательные аргументы

* **queryset** - Итерируемый объект, состоящий из всех узлов, подлежащих кэшированию.
