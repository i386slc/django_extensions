# \{% crispy %\} тег с наборами форм

Тег `{% crispy %}` также поддерживает рендеринг наборов форм, всех видов наборов форм Django: наборов форм, наборов моделей и встроенных наборов форм. В этом разделе считается само собой разумеющимся, что вы знакомы с ранее объясненными концепциями crispy-forms в документации, такими как **FormHelper**, как установить атрибуты **FormHelper** или отобразить простую форму с помощью тега `{% crispy %}`.

## Наборы форм (formsets)

Целью этой документации не является подробное объяснение того, как работают наборы форм, для этого вам следует ознакомиться с [официальной документацией по наборам форм Django](https://docs.djangoproject.com/en/dev/topics/forms/formsets/). Давайте начнем создавать набор форм, используя предыдущую форму **ExampleForm**:

```python
from django.forms.models import formset_factory

ExampleFormSet = formset_factory(ExampleForm, extra=3)
formset = ExampleFormSet()
```

Вот как вы будете отображать набор форм, используя рендеринг по умолчанию, без макетов или помощников форм:

```django
{% raw %}
{% crispy formset %}
{% endraw %}
```

Конечно, можно еще воспользоваться помощником, иначе в этом не было бы ничего "crispy". При использовании **FormHelper** с набором форм по сравнению с использованием его с формой основное отличие состоит в том, что вспомогательные атрибуты применяются к структуре формы, а макет применяется к формам набора форм. Давайте создадим помощник для нашего **ExampleFormSet**:

```python
class ExampleFormSetHelper(FormHelper):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.form_method = 'post'
        self.layout = Layout(
            'favorite_color',
            'favorite_food',
        )
        self.render_required_fields = True
```

За этим помощником довольно легко следовать. Мы хотим, чтобы наша форма использовала метод **POST**, и мы хотим, чтобы **favorite\_color** было первым полем, затем **favorite\_food**, и, наконец, мы говорим crispy отобразить все необходимые поля после. Давайте попробуем использовать его, при использовании тега `{% crispy %}` в шаблоне есть одно основное отличие при рендеринге наборов форм и форм, в этом случае вам нужно явно указать помощника.

Это было бы частью представления гипотетической функции:

```python
formset = ExampleFormSet()
helper = ExampleFormSetHelper()
return render(request, 'template.html', {'formset': formset, 'helper': helper})
```

Затем в **template.html** вам нужно будет сделать:

```django
{% raw %}
{% crispy formset helper %}
{% endraw %}
```

Есть два способа добавить кнопки отправки в набор форм. Используя метод **FormHelper.add\_input**:

```python
helper.add_input(Submit("submit", "Save"))
```

Или вы можете установить для **FormHelper.form\_tag** значение `False` и управлять внешней структурой набора форм по своему желанию, написав скучный HTML:

```django
<form action="{% raw %}
{% url 'save_formset' %}" method="POST">
    {% crispy formset helper %}
{% endraw %}
    <div class="form-actions">
        <input type="submit" name="submit" value="Save" class="btn btn-primary" id="submit-save">
    </div>
</form>
```

Наконец, наборы форм модели и встроенные наборы форм отображаются точно так же, как наборы форм, единственная разница заключается в том, как вы создаете их в своем коде Django.

## Дополнительный контекст

Рендеринг любого набора форм с crispy вводит дополнительный контекст в рендеринг макета, так что вы можете делать такие вещи, как:

```python
class ExampleFormSetHelper(FormHelper):
    def __init__(self, *args, **kwargs):
        super(FormHelper, self).__init__(*args, **kwargs)
        self.form_method = 'post'
        self.layout = Layout(
            HTML('{% raw %}
{% if forloop.first %} Only display text on the first iteration... {% endif %}
{% endraw %}'),
            Fieldset('Item: {{forloop.counter}}', 'field'),
            'favorite_color',
            'favorite_food',
        )
        self.add_input(Submit('submit', 'Save'))
```

По сути, вы можете получить доступ к узлу **forloop** Django, как если бы вы отображали свои формы наборов форм с помощью цикла **for**.

## Пользовательские шаблоны и встроенные формы таблиц

Шаблон набора форм по умолчанию будет отображать форму вашего набора форм с использованием **div**, но часто люди предпочитают **table** для наборов форм. Не волнуйтесь, crispy-forms помогут вам. **FormHelper** имеет атрибут с именем **template**, который можно использовать для указания пользовательского шаблона для отображения формы или набора форм, в данном случае набора форм. Очевидно, когда мы указываем атрибут **template**, мы делаем этот помощник пригодным для использования только с формами или наборами форм.

Имя используемого шаблона — **table\_inline\_formset.html**, и вы используете его:

```python
helper.template = 'bootstrap/table_inline_formset.html'
```

Самое приятное то, что если этот шаблон не делает именно то, что вы хотите, вы можете скопировать его в папку с шаблонами, настроить его, а затем связать своего помощника с альтернативной версией. Если вы считаете, что то, чего вам не хватает, будет полезно другим, отправьте запрос на включение на github.

{% hint style="warning" %}
В настоящее время этот шаблон не учитывает указанный вами макет и работает только с пакетом шаблонов начальной загрузки.
{% endhint %}

## Формы набора форм с различными макетами

По умолчанию рендеринг набора форм crispy-forms использует один и тот же макет для всех форм набора форм. Это так в 99% случаев. Но, может быть, вы хотите отображать формы вашего набора форм, используя разные макеты, которых вы не можете достичь с помощью введенного дополнительного контекста, для этого вам придется создать и использовать собственный шаблон. Скорее всего, вы захотите сделать:

```django
{{ formset.management_form|crispy }}
{% raw %}
{% for form in formset %}
    {% crispy form %}
{% endfor %}
{% endraw %}
```

Где у каждой формы **form** есть атрибут **helper**, из которого crispy-forms захватывает макет. На ваш взгляд, вам нужно будет изменить макет или использовать другой **helper** для каждой формы набора форм. Убедитесь, что для атрибута **form\_tag** установлено значение `False`, иначе вы получите 3 отдельные формы.
